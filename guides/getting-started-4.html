<!DOCTYPE html>
<html lang="en-US">

<head>

    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-126202302-2"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-126202302-2');
    </script>
    
    <meta charset="UTF-8">

    <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>mobx-ui-statelets | Headless state essentials for MobX</title>
<meta name="generator" content="Jekyll v3.8.4" />
<meta property="og:title" content="mobx-ui-statelets" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Headless state essentials for MobX" />
<meta property="og:description" content="Headless state essentials for MobX" />
<link rel="canonical" href="/mobx-ui-statelets/guides/getting-started-4.html" />
<meta property="og:url" content="/mobx-ui-statelets/guides/getting-started-4.html" />
<meta property="og:site_name" content="mobx-ui-statelets" />
<script type="application/ld+json">
{"@type":"WebPage","url":"/mobx-ui-statelets/guides/getting-started-4.html","headline":"mobx-ui-statelets","description":"Headless state essentials for MobX","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="/mobx-ui-statelets/assets/css/style.css?v=">
</head>

<body>
    <header class="page-header top-header">
        <a class="repo-name" href="/mobx-ui-statelets"> mobx-ui-statelets </a>
    </header>
    

    <main id="content" class="main-content" role="main">
        <h1 id="getting-started-guide-part-4-testing">Getting Started Guide Part 4: Testing</h1>

<p>In <a href="/mobx-ui-statelets/guides/getting-started-2.html">part 2</a> and <a href="/mobx-ui-statelets/guides/getting-started-3.html">part 3</a>,
we learnt how keeping the state hierarchy separated from React components made
state headlessly while ensuring real DOM consequence.</p>

<p>In this part we will take the flight booking form in part 3 as an example as to
how we would proceed to test an application with headless state.</p>

<p>In the examples below, we’ll be using <a href="https://jestjs.io/">Jest</a> for the test
runner and assertion, and <a href="https://github.com/airbnb/enzyme">Enzyme</a> for mounting
and inspecting React components. How to set these up are beyond the scope of this guide.
The ideas should be easily adopted using other tools.</p>

<h3 id="possible-kinds-of-test">Possible kinds of test</h3>

<p>There are a few things that we can test when using headless state management:</p>

<ul>
  <li>Testing the headless state in isolation</li>
  <li>Testing a component’s interaction with generic headless state (in abstract context).</li>
  <li>Testing a component receiving the right state (in application/feature context).</li>
</ul>

<p>Let’s look at each one in turn.</p>

<h3 id="testing-the-headless-state-in-isolation">Testing the headless state in isolation</h3>

<p>With headless state, our <code class="highlighter-rouge">AppState</code> now carries the bulk of the logic that we
can test without mounting any React component.</p>

<p>In the last part’s demo, we had a requirement that the hover and focus state of
the inputs dictate the “active” input, which will be used in the presentataion
to show different messages. On the state side, we simply test that the computation
of the active input is correct based on the hover and focus states. We assume at
this stage that the “report” methods represent the points of user interaction.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">AppState</span> <span class="k">from</span> <span class="s2">"../AppState"</span><span class="p">;</span>

<span class="nx">test</span><span class="p">(</span><span class="s2">"active input is not assigned initially"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">appState</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">AppState</span><span class="p">();</span>
  <span class="nx">expect</span><span class="p">(</span><span class="nx">appState</span><span class="p">.</span><span class="nx">activeInput</span><span class="p">).</span><span class="nx">toBeFalsy</span><span class="p">();</span>
<span class="p">});</span>

<span class="nx">test</span><span class="p">(</span><span class="s2">"hover on email input makes it active, unhover unassigns it"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">appState</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">AppState</span><span class="p">();</span>
  <span class="nx">appState</span><span class="p">.</span><span class="nx">email</span><span class="p">.</span><span class="nx">hoverState</span><span class="p">.</span><span class="nx">reportHover</span><span class="p">();</span>
  <span class="nx">expect</span><span class="p">(</span><span class="nx">appState</span><span class="p">.</span><span class="nx">activeInput</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="nx">appState</span><span class="p">.</span><span class="nx">email</span><span class="p">);</span>

  <span class="nx">appState</span><span class="p">.</span><span class="nx">email</span><span class="p">.</span><span class="nx">hoverState</span><span class="p">.</span><span class="nx">reportUnhover</span><span class="p">();</span>
  <span class="nx">expect</span><span class="p">(</span><span class="nx">appState</span><span class="p">.</span><span class="nx">activeInput</span><span class="p">).</span><span class="nx">toBeFalsy</span><span class="p">();</span>
<span class="p">});</span>

<span class="nx">test</span><span class="p">(</span><span class="s2">"hover on email input while focusing on name input makes name input active"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">appState</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">AppState</span><span class="p">();</span>
  <span class="nx">appState</span><span class="p">.</span><span class="nx">email</span><span class="p">.</span><span class="nx">hoverState</span><span class="p">.</span><span class="nx">reportHover</span><span class="p">();</span>
  <span class="nx">appState</span><span class="p">.</span><span class="nx">name</span><span class="p">.</span><span class="nx">focusState</span><span class="p">.</span><span class="nx">reportFocus</span><span class="p">();</span>
  <span class="nx">expect</span><span class="p">(</span><span class="nx">appState</span><span class="p">.</span><span class="nx">activeInput</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="nx">appState</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>

  <span class="nx">appState</span><span class="p">.</span><span class="nx">name</span><span class="p">.</span><span class="nx">focusState</span><span class="p">.</span><span class="nx">reportBlur</span><span class="p">();</span>
  <span class="nx">expect</span><span class="p">(</span><span class="nx">appState</span><span class="p">.</span><span class="nx">activeInput</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="nx">appState</span><span class="p">.</span><span class="nx">email</span><span class="p">);</span>
<span class="p">});</span>

</code></pre></div></div>

<p>With full access to the entire application’s state and its actions, we can
“integration”-test complex user scenario, spanning state that could be presented
in different parts of the React component hierarchy. The test can be much more
comprehensive than the small sample given above.</p>

<p>We assume the “report” methods to represent the user’s “entry point” of interactions.
This we can validate when we unit-test the components, which we will explore next.</p>

<h3 id="testing-a-components-interaction-with-the-headless-state">Testing a component’s interaction with the headless state.</h3>

<p>Here we test that, given a state, the component is behaving in the expected way.
We also test the converse: a user interaction will mutate the state in the
expected way.</p>

<p>The example below tests how the <code class="highlighter-rouge">TextInput</code> component generically interacts with
the <code class="highlighter-rouge">Input</code> state given to it when considering its nestd focus state.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="s2">"react"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">Input</span> <span class="p">}</span> <span class="k">from</span> <span class="s2">"mobx-ui-statelets"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">TextInput</span> <span class="k">from</span> <span class="s2">"../TextInput"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">mount</span> <span class="p">}</span> <span class="k">from</span> <span class="s2">"enzyme"</span><span class="p">;</span>

<span class="nx">test</span><span class="p">(</span><span class="s2">"focusing/blurring on input should report focus state"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Input</span><span class="o">&lt;</span><span class="nx">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">""</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">wrapper</span> <span class="o">=</span> <span class="nx">mount</span><span class="p">(&lt;</span><span class="nc">TextInput</span> <span class="na">name=</span><span class="s2">""</span> <span class="na">inputState=</span><span class="si">{</span><span class="nx">input</span><span class="si">}</span> <span class="p">/&gt;);</span>
  <span class="nx">wrapper</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="s2">"input"</span><span class="p">).</span><span class="nx">simulate</span><span class="p">(</span><span class="s2">"focus"</span><span class="p">);</span>
  <span class="nx">expect</span><span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="nx">focusState</span><span class="p">.</span><span class="nx">isFocused</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>

  <span class="nx">wrapper</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="s2">"input"</span><span class="p">).</span><span class="nx">simulate</span><span class="p">(</span><span class="s2">"blur"</span><span class="p">);</span>
  <span class="nx">expect</span><span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="nx">focusState</span><span class="p">.</span><span class="nx">isFocused</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">test</span><span class="p">(</span><span class="s2">"focus state should be correctly projected"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Input</span><span class="o">&lt;</span><span class="nx">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">""</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">wrapper</span> <span class="o">=</span> <span class="nx">mount</span><span class="p">(&lt;</span><span class="nc">TextInput</span> <span class="na">name=</span><span class="s2">""</span> <span class="na">inputState=</span><span class="si">{</span><span class="nx">input</span><span class="si">}</span> <span class="p">/&gt;);</span>
  <span class="kd">const</span> <span class="nx">el</span> <span class="o">=</span> <span class="p">(</span><span class="nx">wrapper</span><span class="p">.</span><span class="nx">instance</span><span class="p">()</span> <span class="k">as</span> <span class="nx">TextInput</span><span class="p">).</span><span class="nx">el</span> <span class="k">as</span> <span class="nx">HTMLInputElement</span><span class="p">;</span>
  <span class="nx">expect</span><span class="p">(</span><span class="nx">el</span><span class="p">).</span><span class="nx">not</span><span class="p">.</span><span class="nx">toBe</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">activeElement</span><span class="p">);</span>

  <span class="nx">input</span><span class="p">.</span><span class="nx">focusState</span><span class="p">.</span><span class="nx">focus</span><span class="p">();</span>
  <span class="nx">expect</span><span class="p">(</span><span class="nx">el</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">activeElement</span><span class="p">);</span>

  <span class="nx">input</span><span class="p">.</span><span class="nx">focusState</span><span class="p">.</span><span class="nx">blur</span><span class="p">();</span>
  <span class="nx">expect</span><span class="p">(</span><span class="nx">el</span><span class="p">).</span><span class="nx">not</span><span class="p">.</span><span class="nx">toBe</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">activeElement</span><span class="p">);</span>
<span class="p">});</span>

</code></pre></div></div>

<p>When we were testing the headless state in isolation, we assumed that the “report”
methods represent the user actions. In the tests directly above, we could alternatively
spy on the “report” methods to see that they are called in response to our simulation
of user events (<code class="highlighter-rouge">"focus"</code> and <code class="highlighter-rouge">"blur"</code>). What we have chosen instead is asserting
the immediate consequences of those report methods (e.g. asserting <code class="highlighter-rouge">isFocused</code>), which
reasonably imply that the report methods fired in response to the user events.</p>

<p>Similar tests could be written for hover state reporting.</p>

<p>Another requirement we had was the presentation of the correct message depending
on the active input. We can test how our <code class="highlighter-rouge">App</code> component handles this:</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="s2">"react"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">App</span> <span class="k">from</span> <span class="s2">"../App"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">AppState</span> <span class="k">from</span> <span class="s2">"../AppState"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">mount</span> <span class="p">}</span> <span class="k">from</span> <span class="s2">"enzyme"</span><span class="p">;</span>

<span class="nx">test</span><span class="p">(</span><span class="s2">"presents correct help depending on active input"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">appState</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">AppState</span><span class="p">();</span>
  <span class="kd">const</span> <span class="nx">wrapper</span> <span class="o">=</span> <span class="nx">mount</span><span class="p">(&lt;</span><span class="nc">App</span> <span class="na">appState=</span><span class="si">{</span><span class="nx">appState</span><span class="si">}</span> <span class="p">/&gt;);</span>

  <span class="nx">appState</span><span class="p">.</span><span class="nx">name</span><span class="p">.</span><span class="nx">focusState</span><span class="p">.</span><span class="nx">focus</span><span class="p">();</span>
  <span class="nx">expect</span><span class="p">(</span><span class="nx">wrapper</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="s2">"#help"</span><span class="p">).</span><span class="nx">text</span><span class="p">()).</span><span class="nx">toBe</span><span class="p">(</span><span class="s2">"Your last name"</span><span class="p">);</span>

  <span class="nx">appState</span><span class="p">.</span><span class="nx">email</span><span class="p">.</span><span class="nx">focusState</span><span class="p">.</span><span class="nx">focus</span><span class="p">();</span>
  <span class="nx">expect</span><span class="p">(</span><span class="nx">wrapper</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="s2">"#help"</span><span class="p">).</span><span class="nx">text</span><span class="p">()).</span><span class="nx">toBe</span><span class="p">(</span>
    <span class="s2">"The e-mail you used to book the flight"</span>
  <span class="p">);</span>

  <span class="nx">appState</span><span class="p">.</span><span class="nx">flightNumber</span><span class="p">.</span><span class="nx">focusState</span><span class="p">.</span><span class="nx">focus</span><span class="p">();</span>
  <span class="nx">expect</span><span class="p">(</span><span class="nx">wrapper</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="s2">"#help"</span><span class="p">).</span><span class="nx">text</span><span class="p">()).</span><span class="nx">toBe</span><span class="p">(</span><span class="s2">"The flight you want to check-in"</span><span class="p">);</span>

  <span class="nx">appState</span><span class="p">.</span><span class="nx">flightNumber</span><span class="p">.</span><span class="nx">focusState</span><span class="p">.</span><span class="nx">blur</span><span class="p">();</span>
  <span class="nx">expect</span><span class="p">(</span><span class="nx">wrapper</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="s2">"#help"</span><span class="p">).</span><span class="nx">text</span><span class="p">()).</span><span class="nx">toBe</span><span class="p">(</span><span class="s2">""</span><span class="p">);</span>
<span class="p">});</span>

</code></pre></div></div>

<p><em>(Note: in reality you probably wouldn’t be hard-coding these string constants.)</em></p>

<p>Since we would already test the headless state quite comprehensively, here it
should suffice to use whatever easiest way to put the application state into the
required state for presentation.</p>

<p>These tests are generally “unit” and are confined to single components.
They work especially well if your application has reusable components that present
reusable headless state like this <code class="highlighter-rouge">TextInput</code>.</p>

<h3 id="testing-a-component-receiving-the-right-state">Testing a component receiving the right state.</h3>

<p>So far we have tested the integrity of the application state at a holistic level,
and we have unit-tested the components in their ability to generically interact
with state in abstract. What is left is the application context that bridges them
together: testing that in the full-mounted feature or application context, the
right reusable components are receiving the right state instance.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="s2">"react"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">TextInput</span> <span class="k">from</span> <span class="s2">"../TextInput"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">App</span> <span class="k">from</span> <span class="s2">"../App"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">AppState</span> <span class="k">from</span> <span class="s2">"../AppState"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">mount</span> <span class="p">}</span> <span class="k">from</span> <span class="s2">"enzyme"</span><span class="p">;</span>

<span class="nx">test</span><span class="p">(</span><span class="s2">"presents name, email, and flight number inputs"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">appState</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">AppState</span><span class="p">();</span>
  <span class="kd">const</span> <span class="nx">wrapper</span> <span class="o">=</span> <span class="nx">mount</span><span class="p">(&lt;</span><span class="nc">App</span> <span class="na">appState=</span><span class="si">{</span><span class="nx">appState</span><span class="si">}</span> <span class="p">/&gt;);</span>
  <span class="kd">const</span> <span class="nx">inputs</span> <span class="o">=</span> <span class="nx">wrapper</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">TextInput</span><span class="p">);</span>

  <span class="nx">expect</span><span class="p">(</span>
    <span class="nx">inputs</span><span class="p">.</span><span class="nx">filterWhere</span><span class="p">(</span><span class="nx">n</span> <span class="o">=&gt;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">prop</span><span class="p">(</span><span class="s2">"inputState"</span><span class="p">)</span> <span class="o">===</span> <span class="nx">appState</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
  <span class="p">).</span><span class="nx">toHaveLength</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

  <span class="nx">expect</span><span class="p">(</span>
    <span class="nx">inputs</span><span class="p">.</span><span class="nx">filterWhere</span><span class="p">(</span><span class="nx">n</span> <span class="o">=&gt;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">prop</span><span class="p">(</span><span class="s2">"inputState"</span><span class="p">)</span> <span class="o">===</span> <span class="nx">appState</span><span class="p">.</span><span class="nx">email</span><span class="p">)</span>
  <span class="p">).</span><span class="nx">toHaveLength</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

  <span class="nx">expect</span><span class="p">(</span>
    <span class="nx">inputs</span><span class="p">.</span><span class="nx">filterWhere</span><span class="p">(</span><span class="nx">n</span> <span class="o">=&gt;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">prop</span><span class="p">(</span><span class="s2">"inputState"</span><span class="p">)</span> <span class="o">===</span> <span class="nx">appState</span><span class="p">.</span><span class="nx">flightNumber</span><span class="p">)</span>
  <span class="p">).</span><span class="nx">toHaveLength</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">});</span>

</code></pre></div></div>

<p><em>A technical note on Enzyme here: we use reference quality <code class="highlighter-rouge">===</code> over the
<a href="https://airbnb.io/enzyme/docs/api/ReactWrapper/find.html"><code class="highlighter-rouge">filter</code> with property selector</a>
syntax because the latter will only compare own properties. Since
mobx-ui-statelets’s state class properties are almost always
prototypal, all state class instances will likely be seen as equal by own
property values.</em></p>

<h3 id="comparison-with-in-component-state-management">Comparison with in-component state management</h3>

<p>If we had kept our state inside the component, we would arguably write fewer
tests to cover the same logic, since we don’t have a separate state hierarchy to
deal with. However, in order to test the application logic holistically, we
would need to mount and traverse the component hierarchy more often. For
instance, something like this:</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">test</span><span class="p">(</span><span class="s2">"hover on name input changes active input"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">wrapper</span> <span class="o">=</span> <span class="nx">mount</span><span class="p">(&lt;</span><span class="nc">App</span> <span class="p">/&gt;);</span>
  <span class="nx">wrapper</span>
    <span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="cm">/* condition for name input */</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="s2">"input"</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">simulate</span><span class="p">(</span><span class="s2">"focus"</span><span class="p">);</span>
  <span class="nx">expect</span><span class="p">(</span><span class="nx">wrapper</span><span class="p">.</span><span class="nx">state</span><span class="p">().</span><span class="nx">activeInput</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="s2">"name"</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">test</span><span class="p">(</span><span class="s2">"setting the active input changes the text"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">wrapper</span> <span class="o">=</span> <span class="nx">mount</span><span class="p">(&lt;</span><span class="nc">App</span> <span class="p">/&gt;);</span>
  <span class="nx">wrapper</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="na">activeInput</span><span class="p">:</span> <span class="s2">"name"</span> <span class="p">});</span>
  <span class="nx">expect</span><span class="p">(</span><span class="nx">wrapper</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="s2">"#help"</span><span class="p">).</span><span class="nx">text</span><span class="p">()).</span><span class="nx">toBe</span><span class="p">(</span><span class="cm">/* expected text */</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>Just like in-component state lifting, requirement changes that cause state to be
lifted to different places in the component hierarchy will also affect tests.
In Enzyme, <a href="https://airbnb.io/enzyme/docs/api/ReactWrapper/state.html">state access beyond the root component is prohibited</a>,
a restriction aimed at encouraging more unit tests. Depending on how state is
lifted, some tests may need to be completely re-written.</p>

<p>With a headless state architecture, presentational requirement changes will
generally not affect headless state tests, even when the change includes significant
reshuffling of the React component hierarchy. Application logic changes will only
affect React component tests if the changes result in different components
receiving different state.</p>

<p>Headless UI state testing in isolation will usually be more “to the point” in the
way that testing domain state logic in isolation is. Both are free from finding
the correct entry of mutation: This task is delegated to other, much simpler tests
that generally are agnostic of the application state logic.</p>

<h3 id="what-next">What next?</h3>

<p>This article concludes the Getting Started series. At this point, you are ready
to explore what other state classes mobx-ui-statelets has to offer.</p>

<p><a href="/mobx-ui-statelets/guides/">Back to the table of contents</a></p>


        <footer class="site-footer">
            
            <span class="site-footer-owner"><a href="https://github.com/soul-codes/mobx-ui-statelets">mobx-ui-statelets</a> is maintained by <a href="https://github.com/soul-codes">Soul Codes Webentwicklung</a>.</span>
            
        </footer>
    </main>
</body>

</html>